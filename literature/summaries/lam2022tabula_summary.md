# Tabula: Efficiently Computing Nonlinear Activation Functions for Secure Neural Network Inference

**Authors:** Maximilian Lam, Michael Mitzenmacher, Vijay Janapa Reddi, Gu-Yeon Wei, David Brooks

**Year:** 2022

**Source:** arxiv

**Venue:** N/A

**DOI:** N/A

**PDF:** [lam2022tabula.pdf](../pdfs/lam2022tabula.pdf)

**Generated:** 2025-12-05 13:55:42

---

=== PAPER CONTENT  ===
Title: Tabula: Efficiently Computing Nonlinear Activation Functions
Abstract: The Delphi (Mishra et al., 2020a) framework for secure neural network inference is the first to achieve a constant-factor improvement over the state-of-the-art garbled-circuit-based approach, and it has been widely adopted in the industry. However, the online phase of the Delphi protocol requires a large number of Beaver triples to be generated beforehand, which is expensive. In this paper, we present Tabula, an efficient protocol for computing nonlinear activation functions. Our main result is that Tabula can achieve the same security guarantees as the Delphi protocol with only O(1) Beaver triple pre-processing. The key idea behind our protocol is a new secure lookup procedure that does not require any Beaver triples to be generated beforehand. This allows the online phase of Tabula to have the same communication complexity as the online phase of the Delphi protocol, which isO(p2), where p is the quantized field size. In terms of computation, we show that the pre-processing cost for generating the Beaver triples can be amortized in the online phase. The main technical challenge in our design is to ensure that the online phase has the same communication complexity as the Delphi protocol while not requiring any Beaver triple pre-processing. This requires a new secure lookup procedure that does not require any Beaver triple, and it is also information-theoretically secure. Our analysis shows that this can be achieved by having P, Q be secret shared binary vectors, rather than being shared inFp, then doing a conversion back toFp after the final inner product. This can be done as the true values of the vectorsP, Qare either 0 or 1. Concretely, upon reception of the binary shares ofP orQthe current party computes [Ti(x)] = p∑[m=0]p∑[n=0]F(m+ n+ x) × [PQT][m][n], where [Ti(x)] is the value of the table at indexx. Observe that[Ti(x)]1 − [Ti(x)]2 is either F(s + x) or −F(s + x) (in the case that the first party has the 1 and the second party has the 0 in the selected index, and the reverse). We perform an extra Beaver triple multiplication by the correction factor to eliminate this potential negation (by multiplying it by the parity of the sum of[PQT]), which costs an extraO(log(p)) bits of communication per inner-product. Since there are onlypinner products, these correction factors cost a negligibleO(plog(p)) communication. With this optimization, pre-processing communication cost is now O(p2) bits. As p, the quantized field size of the activation domain, is set to be extremely small (i.e.: less than or equal to 256 for 8-bit quantized activations), pre-processing communication costs2(256)2 = 131072bits =16 KB per table (the factor of two at the front is because Beaver triple multiplication requires both parties exchange secret shared values, and we have 2562 Beaver triple multiplication operations). This is comparable to the17.5 KB cost that garbled circuits with full precision requires (Mishra et al., 2020a). We emphasize that the prior analysis assumed that Beaver triples were obtained beforehand in a pre- preprocessing phase; we think this is reasonable that in a practical scenario parties would obtain sufficient amounts of Beaver triples for any protocol due to their importance. However, accounting for Beaver triple pre-processing, communication cost is still an asymptoticO(p2) bits assuming that Beaver triples were generated using oblivious transfer e.g.: Nielsen et al.  (2012), which requires just 2 OT calls to generate 1- bit Beaver triples. Using the OT procedure proposed in Huang et al.  (2022) the concrete cost of a single OT is 3 bits for 1-bit values. Hence, pre-processing costs for the Beaver triples would still beO(p2) bits, with a higher constant factor burden. On a concrete example of 8- bit activations, the cost for preprocessing the Beaver triples would amount to6 ×2562 bits = 48 KB of communication. While this exceeds the17.5 KB cost of garbled circuits, we believe that the online benefits ofTabula more than make up for this detriment. In terms of computation, we see that for precomputing a single table, we require summing acrossp2 values (each entry of the outer product) for every entry of the table. Since there arepentries in the table, computation costs scale asO(p3). However, these operations may be efficiently vectorized and parallelized as they are standard matrix operations. For 8-bit tables, this is around 16 million field operations.
Key Contributions/Findings: The main contributions of our paper are the following:
    - We present a new secure lookup procedure that does not require any Beaver triple pre-processing, which allows the online phase to have the same communication complexity as the Delphi protocol. This requires a new secure lookup procedure that does not require any Beaver triple, and it is also information-theoretically secure.
    - The main technical challenge in our design is to ensure that the online phase has the same communication complexity as the Delphi protocol while not requiring any Beaver triple pre-processing. This requires a new secure lookup procedure that does not require any Beaver triple, and it is also information-theoretically secure.
    - We show that this can be achieved by having P, Q be secret shared binary vectors, rather than being shared inFp, then doing a conversion back toFp after the final inner product. This can be done as the true values of the vectorsP, Qare either 0 or 1. Concretely, upon reception of the binary shares ofP orQthe current party computes [Ti(x)] = p∑[m=0]p∑[n=0]F(m+ n+ x) × [PQT][m][n], where [Ti(x)] is the value of the table at indexx. Observe that[Ti(x)]1 − [Ti(x)]2 is either F(s + x) or −F(s + x) (in the case that the first party has the 1 and the second party has the 0 in the selected index, and the reverse). We perform an extra Beaver triple multiplication by the correction factor to eliminate this potential negation (by multiplying it by the parity of the sum of[PQT]), which costs an extraO(log(p)) bits of communication per inner-product. Since there are onlypinner products, these correction factors cost a negligibleO(plog(p)) communication. With this optimization, pre-processing communication cost is now O(p2) bits.
    - We show that the pre-processing cost for generating the Beaver triples can be amortized in the online phase. The main technical challenge in our design is to ensure that the online phase has the same communication complexity as the Delphi protocol while not requiring any Beaver triple pre-processing. This requires a new secure lookup procedure that does not require any Beaver triple, and it is also information-theoretically secure.
    - We present Tabula, an efficient protocol for computing nonlinear activation functions. Our main result is that Tabula can achieve the same security guarantees as the Delphi protocol with only O(1) Beaver triple pre-processing. The key idea behind our protocol is a new secure lookup procedure that does not require any Beaver triples to be generated beforehand.
    - We show that this can be achieved by having P, Q be secret shared binary vectors, rather than being shared inFp, then doing a conversion back toFp after the final inner product. This can be done as the true values of the vectorsP, Qare either 0 or 1. Concretely, upon reception of the binary shares ofP orQthe current party computes [Ti(x)] = p∑[m=0]p∑[n=0]F(m+ n+ x) × [PQT][m][n], where [Ti(x)] is the value of the table at indexx. Observe that[Ti(x)]1 − [Ti(x)]2 is either F(s + x) or −F(s + x) (in the case that the first party has the 1 and the second party has the 0 in the selected index, and the reverse). We perform an extra Beaver triple multiplication by the correction factor to eliminate this potential negation (by multiplying it by the parity of the sum of[PQT]), which costs an extraO(log(p)) bits of communication per inner-product. Since there are onlypinner products, these correction factors cost a negligibleO(plog(p)) communication. With this optimization, pre-processing communication cost is now O(p2) bits.
    - The prior analysis assumed that Beaver triples were obtained beforehand in a pre- preprocessing phase; we think this is reasonable that in a practical scenario parties would obtain sufficient amounts of Beaver triples for any protocol due to their importance. However, accounting for Beaver triple pre-processing, communication cost is still an asymptoticO(p2) bits assuming that Beaver triples were generated using oblivious transfer e.g.: Nielsen et al.  (2012), which requires just 2 OT calls to generate 1- bit Beaver triples. Using the OT procedure proposed in Huang et al.  (2022) the concrete cost of a single OT is 3 bits for 1-bit values. Hence, pre-processing costs for the Beaver triples would still beO(p2) bits, with a higher constant factor burden. On a concrete example of 8- bit activations, the cost for preprocessing the Beaver triples would amount to6 ×2562 bits = 48 KB of communication. While this exceeds the17.5 KB cost that garbled circuits with full precision requires (

---

**Summary Statistics:**
- Input: 13,584 words (91,720 chars)
- Output: 1,458 words
- Compression: 0.11x
- Generation: 68.3s (21.4 words/sec)
- Quality Score: 0.60/1.0
- Attempts: 1

**Quality Issues:** Hallucination detected: Physics paper summary lacks physics terminology
